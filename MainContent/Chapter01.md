---
sort: 1
---

# 기초 입문서
이 장에서는 Visual Studio 확장을 배우고 개발하기 위한 여정의 시작을 표시합니다. 이 길을 닦기 위해 우리는 이 책을 통해 필요하고 Visual Studio 확장을 개발하기 위한 전제 조건을 빠르게 복습할 것입니다. 이 장은 기본 사항에 대한 입문서 역할을 할 것이며 여기에서 다루는 주제에 정통한 독자는 건너뛸 수 있습니다. 기본 사항을 살펴보기 전에 가장 먼저 떠오르는 질문은 "왜 Visual Studio를 확장해야 합니까?"입니다. 그럼 먼저 답을 드리겠습니다.

***
## 1.1 Visual Studio를 확장해야 하는 이유는 무엇인가요?
왜 Visual Studio IDE를 확장해야 합니까?  

나는 이 질문을 여러 번 들었고 수많은 소프트웨어 개발자가 이 매우 적절한 질문을 하는 것을 보았습니다. 그래서, 우리는 여기 왜? Visual Studio는 훌륭한 IDE이며 개발자를 코딩, 개발, 디버깅 및 문제 해결에서 매우 생산적으로 만듭니다. 그렇다면 굳이 굳이 연장을 해야 하는 이유는 무엇일까요? 글쎄요 – 그렇게 하는 데에는 여러 가지 이유가 있습니다. 상위 항목 중 일부는 다음과 같습니다.

* 요구 사항과 환경에 맞게 Visual Studio를 사용자 지정합니다. 
* 반복적이거나 지루한 작업을 피하기 위해. 확장 기능을 사용하면 버튼 하나만 클릭하면 됩니다. 
* 생산성을 높일 수 있으므로 작업을 더 빠르게 수행하십시오. 스니펫, GUID(Globally Unique Identifier) 생성 도구, 코드 분석, 코드 리팩토링 또는 프로젝트 형태일 수 있습니다.
* 고품질 개발 – Roslyn 분석기, StyleCop, FxCop, CodeMaid, Resharper와 같은 몇 가지 훌륭한 확장 프로그램이 있으며 개발자가 코딩 중에 문제를 식별하는 데 도움이 됩니다. 이렇게 하면 향후 불필요한 버그가 방지되고 코드가 코딩 표준을 준수하여 품질이 향상될 수 있습니다. 
* 팀 전체에 정책 또는 설정을 적용합니다. 대규모 팀에서도 코드 일관성과 균일성을 얻는 데 도움이 되는 확장이 있습니다. 예를 들어 체크인 정책 확장은 각 코드 체크인에 연결된 작업 항목이 있고 StyleCop 및 FxCop 위반이 0개 있는지 확인할 수 있습니다. 이것이 없으면 코드는 확인되지 않습니다. 
* 물론, 명성과 재산은 마켓플레이스에서 무료로 훌륭한 확장 프로그램을 공유하여 커뮤니티에 기여할 수도 있고, 이를 수익화하고 소비자에게 사용료를 청구할 수도 있습니다. 훌륭한 확장 프로그램을 만들면 이름과 명성을 얻고 돈도 벌 수 있습니다. 
* 만약 ... Mads Kristensen이 Visual Studio 시장에서 가장 인기 있는 확장 작성자 중 한 명으로 125개의 확장 기능을 보유하고 있습니다. Visual Studio 확장성에 대한 그의 연설 중 하나에서 그는 새로운 Visual Studio 확장에 대해 어떻게 생각하고 그것을 아름답게 표현했는지 설명했습니다.

Visual Studio Marketplace(https://marketplace.visualstudio.com/)에서 사용할 수 있는 개발자 생산성, 품질, 리팩토링, 편집기 및 컨트롤을 개선하기 위한 Visual Studio용 확장이 많이 있습니다. 현재 시장에는 970만 개 이상의 확장 프로그램이 있으며 다운로드 수는 2,500만 개 이상입니다. 이제 기초를 닦는 탐구를 시작하겠습니다.


## 1.2 Compiler
컴파일러의 기본 정의부터 시작하겠습니다. 컴파일러는 고급 언어로 작성된 모든 컴퓨터 프로그램을 저급 언어로 변환하는 소프트웨어입니다. 컴파일러를 더 자세히 이해하기 전에 이 정의에 사용된 용어를 하나씩 이해합시다.

* 소프트웨어: 컴퓨터에서 실행되는 모든 프로그램을 소프트웨어라고 합니다. 
* 프로그램: 무언가를 수행하는 소프트웨어의 모든 서브루틴, 방법 또는 기능을 프로그램이라고 합니다. 모든 프로그램에는 일반적으로 몇 줄의 코드가 있습니다. 
* 고급 언어: 영어와 같이 인간이 이해할 수 있는 언어에 가깝거나 유사한 모든 프로그래밍 언어를 고급 언어라고 합니다. 인간은 저급 언어에 비해 고급 언어를 이해하기가 훨씬 쉽습니다. C# 및 VB는 고급 언어의 예입니다. 
* 저수준 언어: 컴퓨터의 심장이며 컴퓨터가 받는 모든 명령의 실행을 담당하는 마이크로프로세서는 1과 0의 이진 언어만 이해합니다. 컴퓨터가 이해할 수 있는 이 바이너리 언어를 저수준 언어라고 합니다. 마이크로프로세서는 고급 언어를 있는 그대로 이해하지 못합니다.

따라서 사람이 이해할 수 있는 고급 언어 코드를 컴퓨터가 이해할 수 있는 저수준 언어 코드로 변환하려면 컴파일러가 필요합니다. 컴파일러의 주요 작업은 이러한 필수 변환/포팅을 수행하는 것입니다. 따라서 본질적으로 인간이 코드를 작성하고 컴파일러가 이를 컴퓨터가 이해할 수 있는 형식으로 변환한 다음 컴퓨터가 실행합니다. 

이제 CPU 아키텍처라는 또 다른 중요한 것이 있습니다. 명령을 처리하는 CPU는 32비트 프로세서(x86) 또는 64비트 프로세서(x64)일 수 있습니다. 메모리 공간과 명령어 세트는 이 두 아키텍처에 따라 다릅니다. x64 프로세서에는 64비트 주소와 메모리 공간이 있으므로 더 큰 메모리 주소에서 작동할 수 있습니다. 또한 더 빠른 실행을 위한 최적화로 몇 가지 새로운 지침이 있습니다. 따라서 프로세서를 적절하게 활용하려면 올바른 프로세서 특정 기계어 코드를 생성해야 합니다. 이것은 개발자가 한편으로 CPU의 x86 아키텍처에서 코드를 빌드하고 소프트웨어를 제공한다면 x86 기반 시스템과 x64 기반 시스템 모두에서 잘 작동하지만 최적의 사용을 하지 못할 것이라는 문제를 제시합니다. x64 프로세서. 반면에 개발자가 x64 프로세서에서 코드를 빌드하면 x86 프로세서 기반 시스템에서는 작동하지 않습니다. 

C#.NET 기반 응용 프로그램의 경우 모든 .NET 컴파일러가 코드를 프로세서 아키텍처와 독립적인 Microsoft Intermediate Language 또는 MSIL로 컴파일하므로 일반적으로 문제가 되지 않습니다. 처음 실행 시 이 MSIL은 플랫폼 아키텍처별 기계어로 변환됩니다. 이를 활용하기 위해 .NET 프로젝트 플랫폼(프로젝트 속성에서)을 CPU로 선택할 수 있습니다.

C# 코드가 머신에서 실행되는 방식에 대한 높은 수준의 흐름은 그림 1-1에 나와 있습니다.
![C#코드실행흐름](image/01/01_01_CSharpCodeExecutionFlow.png)   
그림 1-1. C# 코드 실행 흐름

예를 들어 콘솔에 메시지를 표시하는 작업을 수행하는 컴퓨터 프로그램이 있습니다. 코드 편집기를 사용하여 C# 언어로 작성되었습니다. 콘솔에 'Hello World!' 텍스트를 출력하는 샘플 프로그램입니다.

```cs
using System;
namespace BasicsPrimer
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

이 코드는 컴퓨터에서 실행되는 경우 콘솔에 원하는 텍스트를 인쇄합니다. 우리가 직면하게 될 유일한 문제는 컴퓨터가 이 코드를 이해하지 못한다는 것입니다. 0과 1의 이진 언어만 이해합니다. 따라서 이 프로그램을 컴퓨터가 이해하고 실행할 수 있도록 이진 언어로 변환해야 합니다. 컴파일러는 코드를 MSIL로 변환합니다. 프로그램을 실행할 때 .NET CLR(공용 언어 런타임)은 이 MSIL을 JIT(Just-In-Time) 컴파일을 기계 특정 코드로 수행합니다. 이 컴파일은 마이크로프로세서가 이해한 다음 변환된 기계 코드를 실행하여 "Hello World! " 그림 1-2와 같이 콘솔 창에서

![C#코드실행흐름](image/01/01_02_HelloWorld.png)   

그림 1-2. 헬로월드

## 1.3 SDK란?

소프트웨어 개발 키트는 이름에서 알 수 있듯이 소프트웨어를 개발하기 위한 키트입니다. 이를 이해하기 위해 먼저 개발 키트에 대해 알아보겠습니다.  

키트는 무엇이든 만드는 데 필요한 도구 세트입니다(예: 목수가 망치, 끌 등과 같은 가구를 만들기 위해 도구 세트가 필요함). 마찬가지로 소프트웨어를 개발하려면 소프트웨어 개발 키트라고 하는 도구 집합 또는 개발 키트가 필요합니다. 약칭은 SDK입니다. 일반적인 SDK는 개발 환경에서 개발을 지원, 지원 및 용이하게 하는 DLL 및 라이브러리로 구성됩니다.   

.NET에서 작동하는 응용 프로그램을 개발해야 한다고 가정해 보겠습니다. 따라서 응용 프로그램을 개발하려면 .NET SDK가 필요합니다. .NET SDK는 다음(이에 국한되지 않음) 구성 요소로 구성됩니다.

* 개발 중 애플리케이션 실행/디버깅에 필요한 CLR(공용 언어 런타임).
* .NET Framework 등의 내장 기능을 사용하기 위한 BCL(Base Class Library) DLL

다른 SDK는 해당 SDK를 사용하여 소프트웨어를 개발하는 동안 개발자가 필요로 하는 내용에 따라 다른 콘텐츠를 갖습니다. 이 책에서 배우고자 하는 주제와 관련된 예를 하나 더 들 수 있습니다. Visual Studio 확장을 개발하려면 Visual Studio SDK(VSSDK)가 필요합니다. Visual Studio 설치 중에 관련 워크로드(다음 장에서 설명)를 추가하면 기본적으로 Visual Studio 확장을 개발하는 데 필요한 SDK를 설치하게 됩니다. 우리는 이 책을 통해 Visual Studio SDK에 대해 논의하면서 확장을 개발하고 필요에 따라 해당 구성 요소를 탐구할 것입니다.  
6장에서는 Roslyn이라고도 하는 .NET 컴파일러 플랫폼을 사용하는 코드 분석기 및 코드 수정 작업 확장을 개발할 것입니다. Roslyn은 "구문 트리"라고 하는 것을 광범위하게 사용하므로 트리 데이터 구조를 빠르게 요약해 보겠습니다. 트리 데이터 구조의 기본 사항에 이미 익숙하다면 이 새로 고침을 건너뛸 수 있습니다.

## 1.4 트리 데이터 구조 요약
이제 데이터 구조와 알고리즘으로 시작하는 프로그래밍의 몇 가지 기본 사항을 요약해 보겠습니다. 이 주제는 그 자체로 거대합니다. 전체 책이 데이터 구조에 대해 작성되었습니다. 그래서 저는 이 주제에 대한 간략한 요약을 제시하려고 합니다. 이러한 주제에 대한 자세한 내용은 이 책의 범위를 벗어납니다. 이 섹션에서는 트리 데이터 구조를 다시 살펴보겠습니다. 이 리프레셔는 Roslyn 기반 확장으로 작업하는 동안 편리합니다.  

시작하자.  

트리는 소프트웨어 개발 및 프로그래밍에서 많이 사용되는 중요한 데이터 구조입니다. 파일 시스템이나 조직 구조와 같은 모든 계층 구조는 트리 데이터 구조를 사용합니다. 이 장의 뒷부분에서 그리고 확장을 개발하는 동안 보게 될 Roslyn 또는 .NET 컴파일러 플랫폼에는 트리에 대한 지식이 필요합니다. 데이터 구조를 배우기 전에 먼저 추상 데이터 유형(ADT)에 대해 알아야 합니다. ADT는 데이터 구조와 데이터 구조에 대한 모든 가능한 작업의 조합입니다. 우리는 이것을 데이터 구조의 고수준 청사진이라고 부를 수 있습니다.  

따라서 데이터 구조는 본질적으로 ADT의 구현입니다. 예를 들어, 트리는 연결 목록 ADT의 구현인 데이터 구조입니다. 다음은 연결 목록의 ADT 정의입니다. 

"연결 목록은 노드 모음을 보유하고 순차적 방식으로 노드에 액세스하는 메커니즘을 제공하는 추상 데이터 유형(ADT)입니다."

연결 목록의 가장 기본적인 형태는 그림 1-3과 같이 각 노드가 다른 하나의 노드만 가리키는 단일 연결 목록입니다.

![C#코드실행흐름](image/01/01_03_SingleLinkedList.png)   

그림 1-3. 단일 연결 리스트

그림 1-3에서 완전한 각 상자를 노드라고 합니다. 각 노드는 데이터 부분(파란색)과 포인터 부분(노란색)의 두 부분으로 나뉩니다. 포인터 부분에는 연결 목록의 다음 노드에 대한 링크 역할을 하는 포인터(화살표로 표시)가 포함되어 있습니다. 연결 목록의 마지막 노드는 꼬리 노드라고도 합니다. Tail 노드는 다른 노드를 가리키지 않으므로 포인터 부분에 NULL 값이 할당됩니다. 연결 리스트의 첫 번째 노드는 헤드 노드라고도 합니다.  

이제 이 연결 리스트는 노드가 가리키는 노드의 수가 하나 이상이 되면 트리 데이터 구조가 됩니다. 변형을 봅시다.  

먼저 그림 1-4와 같이 수평 연결 리스트를 수직 연결 리스트로 변환합니다.


![C#코드실행흐름](image/01/01_04_TransformSingleLinkedList.png)   
그림 1-4. 변형 단일 연결 리스트

이제 노드당 포인터가 그림 1-5와 같이 노드 중 하나 이상에서 하나 이상이 되도록 노드를 몇 개 추가합니다.

![C#코드실행흐름](image/01/01_05_TreeDataStructure.png)   
그림 1-5. 트리 데이터 구조

그림 1-5에서 원래 연결 리스트의 헤드 노드는 다양한 변형을 거쳐 트리의 루트 노드가 되었습니다. 또한 이 나무는 우리가 현실 세계에서 목격하는 나무와 다릅니다. 거꾸로 된 나무입니다(즉, 진정한 의미에서 거꾸로 된 나무). 그림 1-6에 표시된 실제 트리를 살펴보세요. 그 뿌리는 바닥에 있다.

![](image/01/01_06_Tree.png)   
그림 1-6. 트리 한개

이제 이 트리를 거꾸로 만들면 그림 1-7과 같은 트리 데이터 구조가 됩니다.

![](image/01/01_07_TreeUpsideDown.png)   
그림 1-7. 거꾸로 된 나무

이제 그림 1-8에 표시된 다이어그램을 사용하여 트리 데이터 구조의 다양한 부분을 이해합시다.

![](image/01/01_08_PartTreeDataStructure.png)   
그림 1-8. 트리 데이터 구조의 일부

다음은 부품에 대한 설명입니다.

* 노드: 데이터가 저장되는 트리의 요소. 그림 1-8에서 볼 수 있는 채워지거나 비어 있는 모든 원형 원은 트리의 노드입니다. 
* 루트 노드: 트리 맨 위에 있는 노드를 루트라고 합니다. 트리당 하나의 루트만 있고 루트 노드에서 다른 노드로 가는 하나의 경로가 있습니다.
* 부모 노드: 자식이 있는 노드를 자식의 부모 노드(또는 상위 노드 또는 상위 노드)라고 합니다. 노드에는 최대 하나의 부모가 있습니다. 
* 자식 노드: 부모 노드가 있는 노드를 부모 노드의 자식(하위 노드)이라고 합니다. 노드에는 여러 개의 자식 노드가 있을 수 있습니다. 이진 트리(가장 일반적으로 사용되는 트리 유형)의 모든 노드에는 최대 두 개의 자식이 있을 수 있습니다. 
* 내부 노드: 내부 노드(내부 노드, 줄여서 inode 또는 분기 노드라고도 함)는 자식 노드가 있는 트리의 모든 노드입니다. 
* 외부 노드: 외부 노드(외부 노드, 리프 노드 또는 터미널 노드라고도 함)는 자식 노드가 없는 노드입니다. • 리프 노드: 자식 노드가 없는 노드를 리프 노드라고 합니다.
* 형제 노드: 트리에서 같은 수준에 있는 두 개의 노드를 형제라고 합니다. 
* 하위 트리: 하위 트리는 노드의 자손을 나타냅니다. 
* 분기/에지/링크: 트리의 두 노드 사이의 경로를 나무의 가장자리나 가지.

이제 데이터 구조의 다른 부분을 알았으므로 한 노드에서 다른 노드로 이동하는 방법을 살펴보겠습니다.

트리 순회: 트리 순회는 트리의 모든 노드를 순회하는 방법입니다. 트리 순회 동안 트리의 각 노드는 정확히 한 번 방문됩니다. 트리 데이터 구조를 처리하는 동안 아래 나열된 CRUD 작업에 노드 순회가 필요할 수 있습니다.

1. 새 노드를 생성합니다.
2. 노드 읽기/인쇄
3. 노드를 업데이트/수정합니다.
4. 노드 삭제

트리 순회는 다음 세 가지 방법으로 수행할 수 있습니다.

1. 순차 순회,
2. 선주문 순회,
3. 주문 후 순회.

이러한 메커니즘을 하나씩 이해합시다.  

* 순차 순회  
    이 순회 방법에서는 왼쪽 하위 트리를 먼저 방문한 다음 루트, 오른쪽 하위 트리를 차례로 방문합니다. 우리는 모든 노드가 그 자체로 하위 트리를 나타낼 수 있음을 항상 기억해야 합니다. 순서는 왼쪽-루트-오른쪽입니다. 예시를 통해 이해해보자.  

    그림 1-7과 같이 트리를 순서대로 순회할 수 있습니다. 우리는 머리/루트 노드에서 시작하고 그것은 1이다. 순차순회에 이어 왼쪽 서브트리 노드 2로 이동합니다. 이제 노드 2도 in-order로 탐색됩니다. 모든 노드를 방문할 때까지 프로세스가 계속됩니다. 이 트리의 순서 순회 출력은 다음과 같습니다.

    8, 4, 9, 2, 10, 5, 11, 1, 6, 13, 3, 14, 7

    순차순회 알고리즘은 다음과 같다.  
    
        모든 노드가 순회까지 
            재귀적으로 왼쪽 하위 노드를 순회
            루트 노드 방문
            재귀적으로 오른쪽 하위 노드 순회

* 선 주문 순회
    이 특정 순회에서 이름에서 알 수 있듯이 루트를 먼저 방문한 다음 왼쪽 하위 트리를 방문한 다음 오른쪽 하위 트리를 방문합니다. 노드의 모든 하위 트리는 동일한 사전 주문에 따라 순회해야 합니다. 순서는 root-leftright입니다. 더 나은 이해를 위해 예를 들어 보겠습니다.  

    그림 1-7에 표시된 트리의 선주문 순회를 수행할 수 있습니다. 루트 노드인 1에서 시작합니다. 선주문 순회에 이어 루트 노드를 방문한 다음 왼쪽 하위 트리 노드 2로 이동합니다. 이제 노드 2도 선주문으로 순회됩니다. 모든 노드를 방문할 때까지 프로세스가 계속됩니다. 해당 트리의 선주문 순회 출력은 다음과 같습니다.

    1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 13, 7, 14

    선주문 알고리즘은 다음과 같다.  

        모든 노드가 순회까지 
            루트 노드 방문
            재귀적으로 왼쪽 하위 노드를 순회            
            재귀적으로 오른쪽 하위 노드 순회

* 주문 후 순회
    이 순회 방법에서는 왼쪽 서브트리를 먼저 방문한 다음 오른쪽 서브트리를 방문한 다음 루트 노드를 방문합니다. 이전 순회 방법에서 언급했듯이 모든 노드는 하위 트리 자체를 나타낼 수 있습니다. 왼쪽-오른쪽-루트를 기억하십시오. 예를 들어 최종 순회 방법을 이해합시다. 그림 1-7에 표시된 트리의 후위 순회를 수행할 수 있습니다. 루트 노드인 1에서 시작합니다. 후위 순회에 이어 루트 노드를 읽는 대신 왼쪽 하위 트리 노드 2로 이동합니다. 왼쪽 하위 트리가 탐색되면 오른쪽 하위 트리로 이동합니다. 결국 데이터 노드가 1인 루트 노드를 순회합니다. 순회되는 모든 하위 트리는 항상 후순위 방식으로 순회된다는 점을 기억하십시오. 모든 노드를 방문할 때까지 프로세스가 계속됩니다. 논의 중인 트리의 후위 순회 출력은 다음과 같습니다.

    8, 9, 4, 10, 11, 5, 2, 13, 6, 14, 7, 3, 1

    주문 후 알고리즘은 다음과 같다.  

        모든 노드가 순회까지             
            재귀적으로 왼쪽 하위 노드를 순회            
            재귀적으로 오른쪽 하위 노드 순회
            루트 노드 방문

이러한 모든 탐색에서 왼쪽 하위 트리가 오른쪽 하위 트리보다 먼저 탐색된다는 점에 유의해야 합니다. 루트의 순서만 변경됩니다. 이것은 순회를 마음으로 배울 필요가 없다는 점에서 도움이 될 것입니다.                

순서대로 - 루트가 중간에 방문됩니다.  
선주문 - 루트가 먼저 방문됩니다.  
사후 주문 - 루트가 마지막으로 방문됩니다.

우리는 Roslyn에 대해 논의하는 동안 트리 순회와 특정 유형의 노드 찾기에 대해 조금 더 알게 될 것입니다. Visual Studio는 매우 광범위하며 이러한 확장성의 대부분은 Visual Studio에서 MEF라고 하는 확장성 프레임워크를 기반으로 합니다. 이제 MEF로 넘어갑시다.

