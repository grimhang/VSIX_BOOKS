---
sort: 1
---

# 기초 입문서
이 장에서는 Visual Studio 확장을 배우고 개발하기 위한 여정의 시작을 표시합니다. 이 길을 닦기 위해 우리는 이 책을 통해 필요하고 Visual Studio 확장을 개발하기 위한 전제 조건을 빠르게 복습할 것입니다. 이 장은 기본 사항에 대한 입문서 역할을 할 것이며 여기에서 다루는 주제에 정통한 독자는 건너뛸 수 있습니다. 기본 사항을 살펴보기 전에 가장 먼저 떠오르는 질문은 "왜 Visual Studio를 확장해야 합니까?"입니다. 그럼 먼저 답을 드리겠습니다.

***
## 1.1 Visual Studio를 확장해야 하는 이유는 무엇인가요?
왜 Visual Studio IDE를 확장해야 합니까?  

나는 이 질문을 여러 번 들었고 수많은 소프트웨어 개발자가 이 매우 적절한 질문을 하는 것을 보았습니다. 그래서, 우리는 여기 왜? Visual Studio는 훌륭한 IDE이며 개발자를 코딩, 개발, 디버깅 및 문제 해결에서 매우 생산적으로 만듭니다. 그렇다면 굳이 굳이 연장을 해야 하는 이유는 무엇일까요? 글쎄요 – 그렇게 하는 데에는 여러 가지 이유가 있습니다. 상위 항목 중 일부는 다음과 같습니다.

* 요구 사항과 환경에 맞게 Visual Studio를 사용자 지정합니다. 
* 반복적이거나 지루한 작업을 피하기 위해. 확장 기능을 사용하면 버튼 하나만 클릭하면 됩니다. 
* 생산성을 높일 수 있으므로 작업을 더 빠르게 수행하십시오. 스니펫, GUID(Globally Unique Identifier) 생성 도구, 코드 분석, 코드 리팩토링 또는 프로젝트 형태일 수 있습니다.
* 고품질 개발 – Roslyn 분석기, StyleCop, FxCop, CodeMaid, Resharper와 같은 몇 가지 훌륭한 확장 프로그램이 있으며 개발자가 코딩 중에 문제를 식별하는 데 도움이 됩니다. 이렇게 하면 향후 불필요한 버그가 방지되고 코드가 코딩 표준을 준수하여 품질이 향상될 수 있습니다. 
* 팀 전체에 정책 또는 설정을 적용합니다. 대규모 팀에서도 코드 일관성과 균일성을 얻는 데 도움이 되는 확장이 있습니다. 예를 들어 체크인 정책 확장은 각 코드 체크인에 연결된 작업 항목이 있고 StyleCop 및 FxCop 위반이 0개 있는지 확인할 수 있습니다. 이것이 없으면 코드는 확인되지 않습니다. 
* 물론, 명성과 재산은 마켓플레이스에서 무료로 훌륭한 확장 프로그램을 공유하여 커뮤니티에 기여할 수도 있고, 이를 수익화하고 소비자에게 사용료를 청구할 수도 있습니다. 훌륭한 확장 프로그램을 만들면 이름과 명성을 얻고 돈도 벌 수 있습니다. 
* 만약 ... Mads Kristensen이 Visual Studio 시장에서 가장 인기 있는 확장 작성자 중 한 명으로 125개의 확장 기능을 보유하고 있습니다. Visual Studio 확장성에 대한 그의 연설 중 하나에서 그는 새로운 Visual Studio 확장에 대해 어떻게 생각하고 그것을 아름답게 표현했는지 설명했습니다.

Visual Studio Marketplace(https://marketplace.visualstudio.com/)에서 사용할 수 있는 개발자 생산성, 품질, 리팩토링, 편집기 및 컨트롤을 개선하기 위한 Visual Studio용 확장이 많이 있습니다. 현재 시장에는 970만 개 이상의 확장 프로그램이 있으며 다운로드 수는 2,500만 개 이상입니다. 이제 기초를 닦는 탐구를 시작하겠습니다.


## 1.2 Compiler
컴파일러의 기본 정의부터 시작하겠습니다. 컴파일러는 고급 언어로 작성된 모든 컴퓨터 프로그램을 저급 언어로 변환하는 소프트웨어입니다. 컴파일러를 더 자세히 이해하기 전에 이 정의에 사용된 용어를 하나씩 이해합시다.

* 소프트웨어: 컴퓨터에서 실행되는 모든 프로그램을 소프트웨어라고 합니다. 
* 프로그램: 무언가를 수행하는 소프트웨어의 모든 서브루틴, 방법 또는 기능을 프로그램이라고 합니다. 모든 프로그램에는 일반적으로 몇 줄의 코드가 있습니다. 
* 고급 언어: 영어와 같이 인간이 이해할 수 있는 언어에 가깝거나 유사한 모든 프로그래밍 언어를 고급 언어라고 합니다. 인간은 저급 언어에 비해 고급 언어를 이해하기가 훨씬 쉽습니다. C# 및 VB는 고급 언어의 예입니다. 
* 저수준 언어: 컴퓨터의 심장이며 컴퓨터가 받는 모든 명령의 실행을 담당하는 마이크로프로세서는 1과 0의 이진 언어만 이해합니다. 컴퓨터가 이해할 수 있는 이 바이너리 언어를 저수준 언어라고 합니다. 마이크로프로세서는 고급 언어를 있는 그대로 이해하지 못합니다.

따라서 사람이 이해할 수 있는 고급 언어 코드를 컴퓨터가 이해할 수 있는 저수준 언어 코드로 변환하려면 컴파일러가 필요합니다. 컴파일러의 주요 작업은 이러한 필수 변환/포팅을 수행하는 것입니다. 따라서 본질적으로 인간이 코드를 작성하고 컴파일러가 이를 컴퓨터가 이해할 수 있는 형식으로 변환한 다음 컴퓨터가 실행합니다. 

이제 CPU 아키텍처라는 또 다른 중요한 것이 있습니다. 명령을 처리하는 CPU는 32비트 프로세서(x86) 또는 64비트 프로세서(x64)일 수 있습니다. 메모리 공간과 명령어 세트는 이 두 아키텍처에 따라 다릅니다. x64 프로세서에는 64비트 주소와 메모리 공간이 있으므로 더 큰 메모리 주소에서 작동할 수 있습니다. 또한 더 빠른 실행을 위한 최적화로 몇 가지 새로운 지침이 있습니다. 따라서 프로세서를 적절하게 활용하려면 올바른 프로세서 특정 기계어 코드를 생성해야 합니다. 이것은 개발자가 한편으로 CPU의 x86 아키텍처에서 코드를 빌드하고 소프트웨어를 제공한다면 x86 기반 시스템과 x64 기반 시스템 모두에서 잘 작동하지만 최적의 사용을 하지 못할 것이라는 문제를 제시합니다. x64 프로세서. 반면에 개발자가 x64 프로세서에서 코드를 빌드하면 x86 프로세서 기반 시스템에서는 작동하지 않습니다. 

C#.NET 기반 응용 프로그램의 경우 모든 .NET 컴파일러가 코드를 프로세서 아키텍처와 독립적인 Microsoft Intermediate Language 또는 MSIL로 컴파일하므로 일반적으로 문제가 되지 않습니다. 처음 실행 시 이 MSIL은 플랫폼 아키텍처별 기계어로 변환됩니다. 이를 활용하기 위해 .NET 프로젝트 플랫폼(프로젝트 속성에서)을 CPU로 선택할 수 있습니다.

C# 코드가 머신에서 실행되는 방식에 대한 높은 수준의 흐름은 그림 1-1에 나와 있습니다.
![C#코드실행흐름](image/01/01_01_CSharpCodeExecutionFlow.png)   
그림 1-1. C# 코드 실행 흐름



























* 핵심 절차  
다음 질문을 스스로에게 해보자  
    - 같은 서버에 SQL Server와 리소스 경쟁하는 다른 어플리케이션이 존재하는지?  
        SQL Server보다 우선순위가 높은지 확인. ex) 작업관리자 -> 자세히 -> 컬럼 선택 -> Basic priority 체크
        기본적으로 sqlservr.exe는 노멀 우선순위인데 작업관리자(taskmgr.exe) 프로세스는 높음 우선순위이다.
        우리는 덜 중요한 어플리케이션이나 서비스가 SQL Server와 같은 머신에서 실행되며 자원 사용에 영향을 미치는지 조사 필요.
    - 하드웨어의 용량이 최대 워크로드를 견딜수 있는 상황인지?  
        CPU, 메모리, 디스크, 네트워크
    - SQL Server 구성은 정확한가?  
        sys.configuration 확인
        대부분 디폴트 값이 좋지만 일부분 성능에 영향을 미치는 부분은 언급할것. database 구성 옵션도 model DB에 적용하면 대부분 그 다음에는 만들어지는 것도 그것을 따라감.
    - VM같은 리소스 공유 환경에 내가 영향을 끼쳐 구성을 변경할수 있는지?
    - SQL Server 와 응용프로그램간에 연결은 효율적인지?
        적절한 네트워크 대역폭이 필요. 특히 클라우드 호스팅 환경이면 더 중요.
    - 데이터베이스 디자인은 최적화인지?
        디자인을 수정하는 것은 항상 가능하지 않지만 설계된 디자인을 잘 이해하는 것은 매우 도움이 된다.
    - SQL 쿼리를 구성하는 사용자 워크로드는 SQL Server 로드를 줄이게 최적화 되었는지?
        인덱스와 같은 것들이 적절하게 구성되어야
    - 어떤 프로세스들이 시스템 성능 저하를 일으키는지?
    - 워크로드가 동시성 필요레벨을 지원하는지?  
            
* 절차 반복(Iterating the Process)  
    성능 튜닝은 반복 작업
    - 주요 병목 식별하여 해결하고 변화에 대한 임팩트를 측정 그리고 다시 처음부터. 성능개선활동이 종료될때까지.
    - 해결책을 적용할때는 골든 룰이 있다. 가능한 1번에 1가지 변경만 적용하라. 어떤 변경사항이 시스템의 다른 부분에 영향을 미치는 일이 많기 때문.
    예) 특정 쿼리 성능 문제를 해결하기 위해 인덱스를 추가하면 그로 인해 다른 쿼리들이 느려질 수도.
    - 그렇기에 테스트 서버에서 충분히 테스트를 수행해야 한다.
    - 데이터와 사용량이 증가하면 기존의 쿼리의 실행계획 등이 변경되어 또 다시 나빠질 수 있기 때문에 주기적으로 성능 측정과 튜닝작업을 반복 필요.
    (그림 존재)

***
## 1.2 성능 대 비용
일부 작업들은 약간의 성능 향상을 얻기 위해 많은 시간과 돈이 소비될 수도 있기 때문에 좀더 효율적인 방법을 선택할 수 있어야 한다.

    - 얼마만큼의 성능이면 받아들일 수 있는지
    - 이 작업이 성능향상의 가치가 있는지?
    
* 성능 목표  
    최대 효율을 얻기 위해서 성능 목표치를 정해야 함.  
    베스트 프랙티스가 이미 많이 존재하기 때문에 우리에 맞게 적용하기 전 얼마만큼의 수치면 만족할 수 있을지 정해야 함?
    보통 개발자나 비지니스 수행자들에게 목표를 정하게 하는게 좋은 자세.  
    쿼리 튜닝 같은 개선 활동도 적은 비용으로 효과를 얻고 하드웨어 리소스 투자 같은 방법도 빠르게 성능 향상을 얻을 수 있다.
    단 쿼리 튜닝은 적은 노력으로 큰 효과를 얻지만 전문가가 필요하고 하드웨어 투자는 빠른 효과를 얻지만 큰 비용을 든다. 잘 판단. 경험치 능력자가 매우 중요.
    
* "이정도면 충분" 튜닝
    80:20 법칙이 여기서도 통함. 상위 몇개의 악성 쿼리들만 해결하면 80%의 문제가 해결된다. 이 때 노력은 20%만 소요.  최대 효율을 얻기 위해서는 목표치를 세우고 20%의 노력으로 80%의 문제점을 해결하는 방향으로 하려면 "이정도면 충분" 방법으로 가야.
    
    들인 비용과 성능 개선과의 관계는 반비례 그래프와 같다.
    초기에는 적은 노력으로 큰 향상을 얻지만 나중에는 큰 노력과 비용으로도 적은 결과만 얻게 되니 중간에 "이정도면 충분" 지점에서 끊어야 함.

***
## 1.3 성능 베이스라인
성능 분석의 주요 목표는 여러가지 하드웨어와 소프트웨어 상에서 시스템의 사용과 부하 패턴을 이해하는 것이다.

* 이로 인해 아래의 도움을 얻을 수 있다.
    - 리소스 병목 분석 가능
    - 이전에 측정된 베이스라인과 비교하여 얼마만큼 사용량이 증가하여 트러블슈팅할때 이득
    - 리소스 사용량 계획과 하드웨어 업그레이드 주기 정확한 측정 가능
    - 피크타임을 피하여 데이터베이스 관리 활동하는 시간을 정할수 있음.
    - 특정 수치는 이전 값과 비교할 때만 의미가 있을 수 있다. 예) PLE
    
* 베이스라인이 있으면 가능한 일
    - 현재 성능을 측정하고 어플리케이션 성능 목표치를 세우기 가능
    - 다른 하드웨어와 소프트웨어 조합을 비교 가능
    - 어떻게 사용량과 데이터가 변화하는지 측정
    - 현재 값이 이상하게 튀는 데 진짜 이상 상황인지 아니면 평소와 같은 정상 수치인지
    - 어플리케이션의 피크와 비 피크 사용 패턴 이해. 효과적인 데이터베이스 관리작업 가능. 예를 들면 비 피크타임 일때 백업이나 조각모음을 한다든지
    
    SQL Server의 하드웨어 소프트웨어 리소스 사용량 베이스라인 만들기 위해 성능모니터 이용할 수 있다.  
    또는 DMV나 DMF Xevent를 사용하여 쿼리 부하치 
    또는 기타 툴 MS의 SQLIO, SQLIOSim(시뮬레이션) or Distributed Replay.

***
## 1.4 어디에 노력을 집중 해야?
하드웨어와 OS쪽은 얻는 결과가 작으나 큰 비용이 들며 인덱스나, 쿼리 코딩쪽은 작은 비용이 소요되지만 가장 큰 효과를 본다.    
    
| 항목 | 개선효과 | 응답자 |
|:---:|:----:|:----|
| CPU 전원 절약                | 2% | 6 |
| 다른 하드웨어나 OS 이슈      | 2% | 7 |
| 가상화                       | 2% | 7 |
| SQL Server/데이터베이스 구성 | 3% | 10 |
| 오래되거나 누락된 통계        | 9% | 31 |
| 데이터베이스/테이블 디자인    | 10% | 38 |
| 어플리케이션 코드             | 12% | 43 |
| I/O 서브시스템 문제           | 16% | 60 |
| 잘못된 인덱스 전략            | 19% | 68 |
| T-SQL 코드                   | 26% | 94 |

T-SQL 코드 재작성 이나 인덱스를 적용하는게 실제 가장 큰 효과를 볼 수 있다.  
또한 가장 적은 비용으로 할 수 있고 위쪽으로 갈수록 비용이 많이 든다. 그렇기 때문에 우리는 아래쪽 방법에서 점차 위로 접근해 가장 좋은 솔루션을 선택해야 하는 것이다.

SQL Server 데이터베이스를 이용하는 어플리케이션 쪽에서 2단계로 스트레스 분석해야 한다.
* 고수준 : 각각의 하드웨어 자원과 SQL Server 설치에 걸쳐 얼마나 많은 스트레스가 있는지 측정. 가장 좋은 것은 다양한 대기 상태를 측정하는 것.
            이로 인해 두가지 방법으로 도움을 얻는다.
    - 첫째, 나쁜 성능의 SQL Server 어플리케이션의 어느 부분에 집중해야 하는지 알수 있고
    - 둘째, 적절하지 않은 구성 식별 도움.

    이로 인해 성능 모니터를 사용하여 어플리케이션을 튜닝할 수 없을 경우 어떤 하드웨어 자원을 업그레이드해야 결정 할때 도움.
            
* 저수준 : 범인이 되는 쿼리 식별. Xevent와 DMV 를 통해 알수 있다.
***   
## 1.5 SQL Server 성능 저하 주범들
* 주요 SQL Server 성능 저하 요인들
    - 불충분 인덱스
        보통 가장 큰 원인. CPU, Memory, Disk에 부하 가중.
    - 정확하지 않은 통계
    - 부적절한 쿼리 디자인
    - 나쁜 실행계획
        효율적인 프로시서는 재컴파일하지 않고 생성, 재사용되는데 몇 몇 케이스 동일 메카니즘으로 반복 실행되어도 기대에 어긋나는 결과 발생.
        나쁜 실행계획은 큰 문제 가능. 나쁜 실행계획은 파라메터 스니핑 문제를 발생. 쿼리 옵티마이저가 통계를 바탕으로 실행계획을 만드는 과정에서 발생.
        통계와 실행계획이 어떻게 만들어지는지 이해해야 하고 어떻게 컨트롤 할수 있느지 필요.
    - 과도한 블로킹과 데드락
    - 집합 기준이 아닌 연산. 예 TSQL 커서같은
    - 부적절한 데이터베이스 디자인
    - 과도한 조각화
    - 재사용 불가 실행계획
    - 빈번한 쿼리 재컴파일
    - 부적절한 커서 사용
    - 데이터베이스 트랜잭션 로그의 부적절한 구성
    - tempdb의 과도한 사용 및 부적절한 구성




